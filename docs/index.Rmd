---
title: "Introduction to rasters with `terra`"
author: "Jason Flower, UC Santa Barbara"
date: "`r Sys.Date()`"
output:
  html_document: 
    css: style.css
    toc: TRUE
    toc_float: TRUE
    code_folding: show
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This workshop will provide you with an introduction to manipulating raster spatial data using the R package `terra`. `terra` and its predecessor, `raster` are widely used for spatial data manipulation in R. No prior experience of spatial data is assumed, but this short workshop will not have time to delve into some important aspects of spatial data such as projections. 

`terra`'s predecessor `raster` had many of the same functions as `terra`, and I will mention how functions have changed or been renamed which might be helpful for people migrating from using `raster`. In the words of the creator of both packages: `terra` is simpler, faster and can do more, so definitely switch to `terra` if you are still using `raster`!

*Resources*:

- The official `terra` tutorial page is https://rspatial.org/spatial/index.html  
- An excellent reference to all the functions in `terra` is https://rspatial.github.io/terra/reference/terra-package.html 

<!-- badges: start -->
<!-- badges: end -->

## Prerequisites 

You will need the `terra` package installed, which can be done by running `install.packages("terra")`. If you have problems, there are more details about installing [here](https://rspatial.github.io/terra/index.html). We can then load it

```{r}
library(terra)
```

# Spatial data

There are basically two types of spatial data: vector and raster

## Vector data 
Can be points, lines or polygons. Useful for representing things like survey locations, rivers, and boundaries.

```{r class.source='fold-hide'}
pts <- rbind(c(3.2,4), c(3,4.6), c(3.8,4.4), c(3.5,3.8), c(3.4,3.6), c(3.9,4.5)) |>
  vect()

lnes <- as.lines(vect(rbind(c(3,4.6), c(3.2,4), c(3.5,3.8)))) |>
  rbind(as.lines(vect(rbind(c(3.9, 4.5), c(3.8, 4.4), c(3.5,3.8), c(3.4,3.6)))))

lux <- vect(system.file("ex/lux.shp", package = "terra"))

par(mfrow = c(1,3))

plot(pts, axes = F, main = "Points")
plot(lnes, col = "blue", axes = F, main = "Lines")
plot(lux, "NAME_2", col = terrain.colors(12), las = 1, axes = F, main = "Polygons")

par(mfrow = c(1,3))
```

## Raster data 
Raster data is a grid of rectangles, normally called cells. Each cell can have a value. Rasters are often used to store elevation, temperature, and habitat data, to name just a few examples. 

```{r class.source='fold-hide'}
elev <- system.file("ex/elev.tif", package = "terra") |>
  rast() |>
  aggregate(fact = 2)

plot(elev, las = 1, main = "Elevation map")

elev |>
  as.polygons(aggregate = FALSE, na.rm = FALSE) |>
  lines(col = "grey40", lwd = 0.2)

```

# Getting started

Lets start by creating our own raster. We can create rasters from scratch and load them from a file using the function `rast()`. We can create a simple raster by specifying the x and y limits for the raster and the resolution (how big each rectangle is).

::: {.rasterbox}
`raster` users note: `rast()` replaces `raster()`
:::


```{r}
#create raster
ras <- rast(xmin = 0, xmax = 10, ymin = 0, ymax = 10, resolution = 2)

#see what we've created
ras
```

The figure below shows what most of the terms above refer to. As you can see, you don't need to use all the terms to define a raster. Couple of other points:

- Every object in R has a class, and as you can see, rasters in terra are of class `SpatRaster`. 
- We did not tell `rast()` which coordinate reference system to use, so it defaults to using longitude latitude coordinates, also known as EPSG 4326.

::: {.rasterbox}
`raster` users note: rasters are now `SpatRaster` class not `RasterLayer`
:::

```{r fig.width=6, echo=FALSE}
knitr::include_graphics("../figs/terra_raster_properties_figure.png")
```

But what does the raster we created actually look like when plotted. Lets see. All we need is `plot()`

```{r, out.width=3}
plot(ras)
```

Why is there no plot? Because the raster we created is empty; there are no values associated with the the cells. Lets assign some values to each cell in the raster and try again. First we will find out how many cells are in our raster using `ncell()

```{r}
ncell(ras)
```

Ok, now we know this lets give our raster cells values from 1 to 25:

```{r}
values(ras) <- 1:25

plot(ras)
```

Now our raster has values, we get a plot! Each cell has an integer value between 1 and 25, with cell values increasing from left to right and top to bottom. So the values started being "filled up" in the top left, and finished in the bottom right.

Lets have another look at our raster properties

```{r}
ras
```

We can now see a few extra pieces of information compared to last time:

- `sources(s)`: where is the data held on your computer? It says `memory` for this raster, indicating that the raster is in the computer memory. Rasters can also be held on your hard disk, in which case this will be the file name of the raster. We won't go into details here, but `terra` is smart about loading data into memory; only doing so if it thinks it will have enough space, since most computers have much less memory than hard disk space.
- `name`: what is the raster called?
- `min value` & `max value`: the minimum and maximum values in the raster

Ok, now we understand the basic structure of a raster, lets load some data.

# Exploring some real world data
Sea surface temperature can be measured by satellites, and the National Oceanic and Atmospheric Administration (NOAA) in the U.S. has been doing so since 1972! Daily sea surface temperature for the world from 1985 to the present is available via the [NOAA Coral Reef Watch website](https://coralreefwatch.noaa.gov/product/5km/index_5km_sst.php). 

We are going to explore sea surface temperature (SST) data for the Great Barrier Reef in Australia. All the data is in the `data` folder, and full details on how I got the data are in the `data_prep.R` script in that folder.

## Load the data

We can use the same `rast()` command that we used to make our own raster before. The data is stored in GeoTiff (.tif) format, which is widely used for raster data. You can get a full list of data formats that `terra` can read and write by running `gdal(drivers = TRUE)`.

```{r}
sst <- rast("../data/gbr_temp_2023_05_31.tif")
sst
```

If the data loaded correctly, you should see the properties as shown above. We have all the properties I described earlier, but there are a couple of things worth noting:

- the coordinate reference system (crs) is in lon/ lat, which means the unit of measurement is degrees. So the extent coordinates are in degrees, i.e. xmin = `r sprintf("%1.0f", as.numeric(ext(sst)$xmin))`$^\circ$, xmax = `r sprintf("%0.2f", as.numeric(ext(sst)$xmax))`$^\circ$, ymin = `r sprintf("%0.2f", as.numeric(ext(sst)$ymin))`$^\circ$ and ymax =  `r sprintf("%0.2f", as.numeric(ext(sst)$xmax))`$^\circ$, and resolution is also in degree, i.e `r sprintf("%0.2f", res(sst)[1])`$^\circ$.
- the `source` is the filename of the data we loaded. This means it is on disk, not in memory. We can double check by running `inMemory(sst)` which should return `r inMemory(sst)`.

## Plot the data

We want to plot our data to see what it looks like. This is the first thing you should do with almost any data to do a quick check that it looks right

```{r}
plot(sst)
```

The values in the legend seem about what we would expect in tropical water, temperatures ranging from ~18 - 28$^\circ$ Celsius.

The white areas of the plot are cells with NA values, which in this case are land; there are no sea surface temperature data for the land! We can see Australia taking up much of the plot and Papua New Guinea to the north.

We can set the NA values to a different colour if we want, which can be helpful if you want to see some NA cells that are getting lost against the other colours.

```{r}
plot(sst, colNA = "blue")
```

Note that every cell within our raster has to have a value. 

## Load and plot some vector data
To put our raster data in context, lets plot the Great Barrier Reef Marine Park boundary (dowloaded from [here](https://geohub-gbrmpa.hub.arcgis.com/datasets/bac38dff14ae4ff9a1c9de5d234e26f8_30/explore)). This is vector data. You might be used to handling vector data with the `sf` package, but `terra` can also be used for vector data manipulation. We can load a vector using `vect()`

::: {.rasterbox}
`raster` users note: `terra` has its own methods for handling vector data unlike `raster` which used the `sp` package for vector data handling. Vector data in `terra` are `SpatVector` objects; different from `sf` objects.
:::

```{r}
#load the park boundary
gbr_boundary <- vect("../data/gbr_MPA_boundary.gpkg")

#plot the SST data and the boundary on top
plot(sst)
lines(gbr_boundary) #this plots the vector lines over the raster data
```


## Crop and mask data

The data we have at the moment is for a much larger area than just the Great Barrier Reef marine park. To get only that data we need to crop and mask the raster data using the marine park boundary.

Cropping means that keep only the data inside the **extent** of the vector we are using. Mask means that all the data outside the vector is set to NA or some other value we specify. Lets have a look how this works.

First lets have a look at the extent of the marine park boundary. We can get the extent of an object using `ext()`. We need to convert this into a `SpatVector` object for plotting using `vect()`. We only need to do this for plotting; when we crop, we can just use marine park boundary vector.

::: {.rasterbox}
`raster` users note: `ext()` replaces `extent()`
:::

```{r fig.cap="Cropping means we remove everything outside the extent (blue box) of our polygon. Masking sets all values outside our polygon to NA."}
gbr_boundary_extent <- ext(gbr_boundary) |>
  vect()

plot(sst)
lines(gbr_boundary)
lines(gbr_boundary_extent, col = "blue")
```

So when we crop, we get only the area within the blue box.

We crop using the `crop()` function, using the raster we want to crop as the first argument and the vector we are cropping with second.

```{r}
#crop
sst_cropped <- crop(sst, gbr_boundary)

#plot
plot(sst_cropped)
lines(gbr_boundary)
```

Now we cropped our raster, we can mask it so that we only have values for the area within the Great Barrier Reef marine park boundary. We do this using `mask`

```{r}
#mask
sst_cropped_masked <- mask(sst_cropped, gbr_boundary)

#plot
plot(sst_cropped_masked)
lines(gbr_boundary)
```

So now we only see raster values for cells that are within the Great Barrier Reef marine park boundary. But remember that the areas that are white, still have values in our raster, they are just `NA` values.

Often we want to `crop` and `mask` one after the other, and you can do this in one command using `crop(sst, gbr_boundary, mask = TRUE)`. 

For reference, here is a figure comparing what `crop`, `mask` and `crop(mask = TRUE)` do:

```{r class.source='fold-hide'}
par(mfrow = c(2,2))

plot(sst, main = "Original raster")
lines(gbr_boundary)

plot(sst_cropped, main = "Cropped")
lines(gbr_boundary)

sst |>
  mask(gbr_boundary) |>
  plot(main = "Masked")
lines(gbr_boundary)

plot(crop(sst, gbr_boundary, mask = TRUE), main = "Cropped and masked")
lines(gbr_boundary)

par(mfrow = c(1,1))
```

## Raster values

Now we have cropped and masked our original raster to get only data within the area we are interested in, we can start exploring the values. `terra` has several functions that can help us do this easily.

### Histogram

We can get a histogram of the temperature values using the `hist()` function.

```{r}
hist(sst_cropped_masked)
```

The x-axis has is our raster values measurement; in our case temperature in degrees Celsius. The y-axis is frequency; how many cells in our raster have those values.

You can change modify the histogram using the same arguments you use with `hist()` in base R, for example lets increase the number of bars we have:

```{r}
hist(sst_cropped_masked, breaks = 100)
```

### Frequency table 
We can get a frequency table of values in our raster using `freq()`. This is essentially the same information that is shown in the histogram in graphical format.

```{r}
freq(sst_cropped_masked)
```

The default is to round values to the nearest integer. To get more integers we can do:

```{r}
freq(sst_cropped_masked, digits = 1) |>
  head() #this is a long table: just show the first few values
```

We can also check how many NA values are in our raster:

```{r}
freq(sst_cropped_masked, value = NA)
```

### Statistics

We can use the same `summary()` command that is used in base R, to get a summary of the statistical information for an entire raster.

```{r}
summary(sst_cropped_masked)
```

These values are, for example, the mean value of all raster values, with NA values excluded.

To get individual statistical values, we need the function `global()`. For example to get the mean value of a raster:

```{r}
global(sst_cropped_masked, "mean", na.rm = TRUE)
```

We need to use `na.rm = TRUE` otherwise `NA` values are included and the mean is `NaN`. The object returned by `global` is a data frame, so if you want just the value, you need to do:

```{r}
sst_mean <- as.numeric(global(sst_cropped_masked, "mean", na.rm = TRUE))

sst_mean
```

::: {.rasterbox}
`raster` users note: `global()` replaces `cellStats()`, and the default is `na.rm = FALSE`, whereas the default for `cellStats()` was `na.rm = TRUE`.
:::

### Classifying

We might want to break our raster values into groups. For example, we could say that all temperatures that are below the mean temperature are classified as "cooler" and all temperatures above the mean are "warmer". We can do this using the `classify` function.

::: {.rasterbox}
`raster` users note: `classify()` replaces `reclassify()`
:::

```{r}
#first we create a matrix that will be used for the classification
# all values >= 0 and less than the mean become 1
# all values greater than the mean become 2
reclass_matrix <- c(0, sst_mean, 1,
                    sst_mean, Inf, 2) |>
  matrix(ncol = 3, byrow = TRUE)

#now we classify our raster using this matrix
sst_reclassed <- classify(sst_cropped_masked, reclass_matrix)

#plot the result
plot(sst_reclassed)
```

A gut check tells us this looks right; the warmer areas are in the north, nearer to the equator. 

This plot is ok, but it would be better if the colours were more appropriate and the legend gave some useful information. 

```{r}
plot(sst_reclassed, col = c("blue", "red"), plg = list(legend = c("Cooler", "Warmer")), las = 1) #the las = 1 argument just rotates the y-axis labels so that they are horizontal
```

### Raster math

The great thing about rasters are you can do maths with them! For example, doing `sst_reclassed + 1` just adds one to each raster value, and doing `sst_reclassed*2` multiplies each raster value by two.

As an example, lets convert our temperature data into Fahrenheit for our confused colleagues in the U.S. The conversion from Celsius to Fahrenheit is: Fahrenheit = (Celsius * 1.8) + 32.

```{r}
#do the conversion
sst_fahrenheit <- (sst_cropped_masked*1.8) + 32

#plot our new raster
plot(sst_fahrenheit)
```


## Nice maps

Lets also make the map a bit prettier, choosing more appropriate colours and adding a scale bar

```{r}
plot(sst_fahrenheit, col = hcl.colors(50, palette = "RdYlBu", rev = TRUE), las = 1) #see ?hcl.colors for more info on colour palettes. rev= TRUE because we want to reverse the palette: red colours are the highest values and blue the lowest
lines(gbr_boundary)
sbar(d = 400, type = "bar", divs = 2, below = "km") #400km bar with 2 divisions and "km" written below
```

<details>
<summary>More info on colour palettes</summary>

Code is directly from the `?hcl.colors()` Examples. This 
```{r class.source='fold-hide'}
## color swatches for HCL palettes
hcl.swatch <- function(type = NULL, n = 5, nrow = 11,
  border = if (n < 15) "black" else NA) {
    palette <- hcl.pals(type)
    cols <- sapply(palette, hcl.colors, n = n)
    ncol <- ncol(cols)
    nswatch <- min(ncol, nrow)

    par(mar = rep(0.1, 4),
        mfrow = c(1, min(5, ceiling(ncol/nrow))),
        pin = c(1, 0.5 * nswatch),
        cex = 0.7)

    while (length(palette)) {
        subset <- 1:min(nrow, ncol(cols))
        plot.new()
        plot.window(c(0, n), c(0, nrow + 1))
        text(0, rev(subset) + 0.1, palette[subset], adj = c(0, 0))
        y <- rep(subset, each = n)
        rect(rep(0:(n-1), n), rev(y), rep(1:n, n), rev(y) - 0.5,
             col = cols[, subset], border = border)
        palette <- palette[-subset]
        cols <- cols[, -subset, drop = FALSE]
    }

    par(mfrow = c(1, 1), mar = c(5.1, 4.1, 4.1, 2.1), cex = 1)
}
```

```{r fig.width=8, fig.height=6}
hcl.swatch("qualitative")
hcl.swatch("sequential")
hcl.swatch("diverging")
hcl.swatch("divergingx")
```

</details>

## Rasterlayers

A very useful feature of rasters is that they can have many layers. These layers often represent different time periods, such as days or months. Lets look at a multi-layer raster which has the same temperature data that we have been looking at, but each layer represents the mean temperature in a month. We load the multi-layer raster in the same way as any other raster, using `rast()`:

```{r}
sst_monthly <- rast("../data/gbr_monthly_temp.tif")

sst_monthly
```

We can that the raster has `r nlyr(sst_monthly)` layers. Lets plot it to see what we get.

```{r}
plot(sst_monthly)
```

We get one map for each raster layer, but not all the data because you wouldn't be able to see the maps if they were much smaller. We can plot a specific subset of the data using double square brackets `[[]]` to select a set of layers. For example, if we wanted the last 4 layers in the raster, which are layers 33 to 36:

```{r}
plot(sst_monthly[[33:36]])
```

Happily, we can use the same functions we have learnt on this multi-layer raster. For example, we can convert all the rasters to Fahrenheit:

```{r}
sst_monthly_fahrenheit <- (sst_monthly * 1.8) + 32

plot(sst_monthly_fahrenheit)
```

We can also crop and mask our data:

```{r}
sst_monthly_cropped_masked <- crop(sst_monthly, gbr_boundary, mask = TRUE)

plot(sst_monthly_cropped_masked)
```


## Extracting data

We have been looking at data within the Great Barrier Reef Marine Park boundary. What if we want to extract data for some areas within that area? For example we might want to know the temperature within some of the zones within the marine park. We could crop and mask our data for each of our zones, but this could get messy if we have a lot of zones. Happily there is an easier way.

First lets load the geospatial data for two habitat protection zones in the Great Barrier Reef. This is just a small part of the [Great Barrier Reef Marine Park zoning map](https://geohub-gbrmpa.hub.arcgis.com/datasets/GBRMPA::great-barrier-reef-marine-park-zoning-/explore). Surprisingly, habitat protection zones allow all types of fishing except trawling. You can view more details about the zones and the activities that are allowed [here](https://www2.gbrmpa.gov.au/access/zoning/interpreting-zones).

```{r}
#load the zones data
zones <- vect("../data/gbr_habitat_protection_zones.gpkg")

#take a look
zones
```

There are lots of columns, but lets use the "PERMIT_DESC" column, which is actually the zone location, to map them since it has distinct and interesting descriptions for them.
```{r}
#plot the zones with our temperature data
plot(zones, "PERMIT_DESC")
```

Lets plot them over our temperature data for context.

```{r}
plot(sst_cropped_masked)
lines(zones)
```

Although we have been able to plot the zones and the temperature raster together, they are actually in different coordinate reference systems.

```{r}
crs(sst_cropped_masked)
```

Well, that's a lot of information. This is the "well-known text" version of the coordinate reference system. To get just some basic information that most of the time is all we need, we can do:

```{r}
crs(sst_cropped_masked, describe = TRUE)
```

```{r}
crs(zones, describe = TRUE)
```



```{r}
zonal(sst_cropped_masked, zones, fun = "mean")
```


```{r}
zonal(sst_cropped_masked, zones, fun = "max")
```


```{r}
zones_data_df <- extract(sst_cropped_masked, zones)

zones_data_df
```

```{r}
boxplot(CRW_SST_2 ~ ID, zones_data_df)
```

